#include "ap_main.h"

Button_Handler_t hBtnLeft;
Button_Handler_t hBtnRight;
Button_Handler_t hBtnOnOff;

enum {OFF, LEFT, RIGHT};

void TIM2_IRQHandler()
{
	FND_DisplayData();
	TIM_ClearUIFlag(TIM2); //flag clear
}

int ap_main()
{

   uint8_t data = 1;
   uint16_t counter = 0;
   int led_state = OFF;

   while(1)
   {
	   FND_WriteData(counter++);
	   delay(300);
      //FND_DisplayData();
      switch(led_state)
      {
      case OFF:
         if(Button_GetState(&hBtnLeft) == ACT_PUSHED){
            led_state = LEFT;
         }
         else if(Button_GetState(&hBtnRight) == ACT_PUSHED){
            led_state = RIGHT;
         }
         LEDBar_Write(0);
         break;
      case LEFT:
         data = (data << 1) | (data >> 7);
         if(Button_GetState(&hBtnOnOff) == ACT_PUSHED){
            led_state = OFF;
         }
         else if(Button_GetState(&hBtnRight) == ACT_PUSHED){
            led_state = RIGHT;
         }
         LEDBar_Write(data);
         break;
      case RIGHT:
         data = (data >> 1) | (data << 7);
         if(Button_GetState(&hBtnOnOff) == ACT_PUSHED){
            led_state = OFF;
         }
         else if(Button_GetState(&hBtnLeft) == ACT_PUSHED){
            data = 1;
            led_state = LEFT;
         }
         LEDBar_Write(data);
         break;
      }
      delay(1);

   }

   return 0;
}

void ap_Init()
{
   SystemClock_Init();
   LedBar_Init();
   Button_Init(&hBtnLeft, GPIOB, 5);
   Button_Init(&hBtnRight, GPIOB, 3);
   Button_Init(&hBtnOnOff, GPIOA, 10);
   FND_Init();
   TIM_Init(TIM2, 16-1,1000-1); //100MHz를 분주하기 위해 psc =16, arr = 1000으로 설정  -> 1ms
   TIM_CntStart(TIM2);
   TIM_UInterEnable(TIM2);  //Interrupt 용, 내부적으로 Count값 증가
   NVIC_EnableIRQ(TIM2_IRQn); //TIM2를 등록하여 사용

   //TIMER 5번은 Interrupt없이 Tick 세기 위해 사용
   TIM_Init(TIM5, 16000-1,0xffffffff);
   TIM_CntStart(TIM5);
   SysTick_Init(TIM5);
   SysTick_Start();
}

/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f411xe.h"
//#include "GPIO.h"
#include "LedBar.h"


#define PERIPH_BASE (0x40000000UL)
#define APB1PERIPH_OFFSET (0x00000UL)
#define APB2PERIPH_OFFSET (0x10000UL)
#define AHB1PERIPH_OFFSET (0x20000UL)

#define APB1PERIPH_BASE (PERIPH_BASE + APB1PERIPH_OFFSET)
#define AP21PERIPH_BASE (PERIPH_BASE + APB2PERIPH_OFFSET)
#define AHB1PERIPH_BASE (PERIPH_BASE + AHB1PERIPH_OFFSET)

#define GPIOA_OFFSET (0x0000UL)
#define GPIOB_OFFSET (0x0400UL)
#define GPIOC_OFFSET (0x0800UL)
#define GPIOD_OFFSET (0x0C00UL)
#define RCC_OFFSET   (0x3800UL)

#define GPIOA_BASE (AHB1PERIPH_BASE + GPIOA_OFFSET)
#define GPIOB_BASE (AHB1PERIPH_BASE + GPIOB_OFFSET)
#define GPIOC_BASE (AHB1PERIPH_BASE + GPIOC_OFFSET)
#define GPIOD_BASE (AHB1PERIPH_BASE + GPIOD_OFFSET)
#define RCC_BASE   (AHB1PERIPH_BASE + RCC_OFFSET)


#define GPIOA_MODER   *(volatile uint32_t *)(GPIOA_BASE + 0x00)
#define GPIOA_OTYPER  *(volatile uint32_t *)(GPIOA_BASE + 0x04)
#define GPIOA_OSPEEDR *(volatile uint32_t *)(GPIOA_BASE + 0x08)
#define GPIOA_PUPDR   *(volatile uint32_t *)(GPIOA_BASE + 0x0C)
#define GPIOA_IDR     *(volatile uint32_t *)(GPIOA_BASE + 0x10)
#define GPIOA_ODR 	  *(volatile uint32_t *)(GPIOA_BASE + 0x14)
#define GPIOA_BSRR 	  *(volatile uint32_t *)(GPIOA_BASE + 0x18)
#define GPIOA_LCKR 	  *(volatile uint32_t *)(GPIOA_BASE + 0x1C)
#define GPIOA_AFRL 	  *(volatile uint32_t *)(GPIOA_BASE + 0x20)
#define GPIOA_AFRH 	  *(volatile uint32_t *)(GPIOA_BASE + 0x24)

#define GPIOB_MODER   *(volatile uint32_t *)(GPIOB_BASE + 0x00)
#define GPIOB_OTYPER  *(volatile uint32_t *)(GPIOB_BASE + 0x04)
#define GPIOB_OSPEEDR *(volatile uint32_t *)(GPIOB_BASE + 0x08)
#define GPIOB_PUPDR   *(volatile uint32_t *)(GPIOB_BASE + 0x0C)
#define GPIOB_IDR     *(volatile uint32_t *)(GPIOB_BASE + 0x10)
#define GPIOB_ODR 	  *(volatile uint32_t *)(GPIOB_BASE + 0x14)
#define GPIOB_BSRR 	  *(volatile uint32_t *)(GPIOB_BASE + 0x18)
#define GPIOB_LCKR 	  *(volatile uint32_t *)(GPIOB_BASE + 0x1C)
#define GPIOB_AFRL 	  *(volatile uint32_t *)(GPIOB_BASE + 0x20)
#define GPIOB_AFRH 	  *(volatile uint32_t *)(GPIOB_BASE + 0x24)

#define GPIOC_MODER   *(volatile uint32_t *)(GPIOC_BASE + 0x00)
#define GPIOC_OTYPER  *(volatile uint32_t *)(GPIOC_BASE + 0x04)
#define GPIOC_OSPEEDR *(volatile uint32_t *)(GPIOC_BASE + 0x08)
#define GPIOC_PUPDR   *(volatile uint32_t *)(GPIOC_BASE + 0x0C)
#define GPIOC_IDR     *(volatile uint32_t *)(GPIOC_BASE + 0x10)
#define GPIOC_ODR 	  *(volatile uint32_t *)(GPIOC_BASE + 0x14)
#define GPIOC_BSRR 	  *(volatile uint32_t *)(GPIOC_BASE + 0x18)
#define GPIOC_LCKR 	  *(volatile uint32_t *)(GPIOC_BASE + 0x1C)
#define GPIOC_AFRL 	  *(volatile uint32_t *)(GPIOC_BASE + 0x20)
#define GPIOC_AFRH 	  *(volatile uint32_t *)(GPIOC_BASE + 0x24)

/*typedef struct{
	volatile uint32_t MODER;
	volatile uint32_t OTYPER;
	volatile uint32_t OSPEEDR;
	volatile uint32_t PUPDR;
	volatile uint32_t IDR;
	volatile uint32_t ODR;
	volatile uint32_t BSRR;
	volatile uint32_t LCKR;
	volatile uint32_t AFR[2];
	//volatile uint32_t AFRL;
	//volatile uint32_t AFRH;
} GPIO_TypeDef;
*/

#define GPIOA  ((GPIO_TypeDef *)(GPIOA_BASE))
#define GPIOB  ((GPIO_TypeDef *)(GPIOB_BASE))
#define GPIOC  ((GPIO_TypeDef *)(GPIOC_BASE))


#define RCC    ((RCC_TypeDef *)(RCC_BASE))


//#define RCC_AHB1ENR *(volatile uint32_t *)0x40023830

void delay();

int main(void)
{
	uint32_t data = 0x01;
    /* 1. Enable clock access to GPIOA */
	//RCC_AHB1ENR |= (1U << 0); //RCC_AHB1ENR
	RCC-> AHB1ENR |= (7U << 0);
	/* 2. Set PA5 as output pin */
	//GPIOA-> MODER |= (1U << 10); //GPIOA MODER
	//GPIOA-> MODER &= ~(1U << 11); //GPIOA MODER
	for(int i = 0; i<7; i++){
		GPIO_init(GPIOA,i,OUTPUT);
	}

	for(int i = 0; i<7; i++){
		GPIO_init(GPIOB,i,OUTPUT);
	}

	for(int i = 0; i<7; i++){
		GPIO_init(GPIOC,i,OUTPUT);
	}


	while(1)
	{
		int flag = 1;


		if((~GPIO_ReadPin(GPIOC,13))){
			flag = ~flag;
		} else {
			flag = flag;
		}

		if(flag){
			data = (data << 1) | (data >> 7);
		} else {
			data = (data >> 1) | (data << 7);
		}

		LEDBar_Write(data);
		delay();
		delay();

		//LEDBar_Write(0x55);
		//delay();
		//delay();
	}
}

void delay() {
    for (volatile int i = 0; i < 100000; i++);
}
